# 해시 알고리즘이란

해시 알고리즘은 **임의 길이의 입력(메시지)을 고정 길이의 출력(해시값, digest)**으로 변환하는 함수이다.
입력의 ‘지문’을 만드는 것처럼 동작해서, 원본을 압축·식별·검증하는 데 주로 사용된다.

---

# 핵심 특성 (정의적 요약)

1. **결정적**이다 — 같은 입력이면 항상 같은 해시값이 나온다.
2. **고정 길이 출력**이다 — 입력 길이와 무관하게 항상 일정 크기(예: SHA-256 = 256비트)를 반환한다.
3. **단방향성(one-way)**이다 — 해시값만으로 원본을 현실적으로 복원할 수 없다.
4. **민감성(avalanche effect)**이다 — 입력 비트 하나만 바꿔도 해시 전체가 크게 달라진다.
5. **충돌 가능성 존재**이다 — 서로 다른 입력이 같은 해시를 가질 수 있으나, 좋은 해시는 충돌 확률이 극히 낮다.

---

# 내부 구조(일반적 구성요소)

대부분의 해시(특히 암호학적 해시)는 비슷한 설계 패턴을 가진다.

1. **패딩(Padding)**

   * 메시지를 블록(예: 512비트) 단위로 맞추기 위해 `1`비트 + 0으로 채우고 길이를 붙인다.

2. **초기값(IV, 초기 해시 상태)**

   * 알고리즘마다 고정된 초기 상태(H0..Hn)가 존재한다.

3. **메시지 스케줄(확장)**

   * 블록을 워드 단위로 분할한 뒤 추가 워드를 만들어 냄(입력 확장)이다.

4. **압축 함수(Compression)**

   * 라운드(반복)마다 상태와 메시지 워드를 섞어 상태를 갱신한다(비트 회전, XOR, 덧셈 등 사용).

5. **중간/최종 갱신**

   * 블록마다 상태를 누적해서 최종 해시를 생성한다.

대표적 예: SHA-256은 512비트 블록, 64 라운드, 8개의 32비트 레지스터를 사용한다.

---

# 설계 방식(구조 패턴)

* **Merkle–Damgård 구조**: MD5, SHA-1, SHA-2 계열이 사용하는 구조이다. 블록 단위 압축을 반복해서 처리한다.
* **Sponge 구조**: SHA-3(Keccak)가 사용하는 방식이다. 흡수(입력 섞기) + 출력(해시 추출) 단계로 동작한다.
  각 구조는 확장성, 보안 특성에서 차이가 있다.

---

# 보안성(암호학적 속성)

암호학적 해시가 만족해야 하는 주요 성질은 다음과 같다.

1. **Preimage resistance (역저항성)**

   * 주어진 해시 y가 있을 때, x를 찾아 h(x)=y인 x를 찾는 것이 계산적으로 불가능해야 한다.

2. **Second-preimage resistance (두번째 역저항성)**

   * 주어진 x와 h(x)가 있을 때, x' ≠ x를 찾아 h(x') = h(x)가 되는 x'를 찾기 어렵다.

3. **Collision resistance (충돌저항성)**

   * 서로 다른 x, x' 쌍을 찾아 h(x)=h(x')가 되는 경우를 찾기 매우 어렵다.

참고: 충돌저항성은 가장 강한 요구사항이며, 공격이 쉬워지면 안전에 치명적이다(예: MD5, SHA-1은 충돌 공격이 실용적으로 가능).

---

# 유명한 해시 알고리즘 정리

* **MD5** — 128비트, 빠르지만 충돌 취약 → 보안 용도에는 부적합이다.
* **SHA-1** — 160비트, 충돌 공격 존재 → 보안용 권장 안 함이다.
* **SHA-2 (SHA-224/256/384/512)** — 널리 사용되며, 안전성이 높다(현시점 기준).
* **SHA-3 (Keccak)** — sponge 구조, SHA-2와 다른 설계 원리이다.
* **BLAKE2, BLAKE3** — 빠르고 안전한 현대적 해시, 성능이 우수하다.

---

# 해시의 실제 활용 사례

1. **비밀번호 저장**: 평문 대신 해시 + salt로 저장한다(단독 해시 사용은 취약하다).
2. **데이터 무결성**: 파일 다운로드 시 체크섬 비교(SHA-256 등)로 검증한다.
3. **디지털 서명**: 메시지를 해시한 뒤 서명 → 서명 크기 절약 및 처리 속도 향상이다.
4. **해시 테이블**: 키를 해시값으로 매핑하여 빠른 조회가 가능하다(비암호학적 해시 사용).
5. **암호학적 프로토콜**: 난수 생성, 키 파생(KDF), HMAC 등에 사용된다.

---

# 보안적으로 추가해야 할 것들 (실무 팁)

* **Salt**: 동일 비밀번호에 대해 다른 해시가 나오도록 무작위 salt를 추가해야 한다.
* **Pepper**: 서버 측 비밀값(추가 고유 데이터)로 보안 강화가 가능하다.
* **KDF 사용**: 비밀번호 저장 시 PBKDF2, bcrypt, scrypt, Argon2 같은 키 유도 함수를 사용해야 한다(반복 비용으로 무차별 공격 비용 증가).
* **HMAC**: 해시만으로 무결성/인증을 처리하지 말고 비밀 키 기반 HMAC을 사용해야 한다.

---

# 해시 관련 공격 종류(요약)

* **브루트포스(무차별)**: 입력을 계속 대입해서 해시값을 맞추는 방식이다(길이·복잡도에 의해 방지 가능).
* **레인보우 테이블**: 사전 계산된 해시→원본 테이블로 빠르게 역조회한다(해시+salt로 방지).
* **충돌 공격**: 서로 다른 두 입력이 같은 해시를 만들도록 조작한다(약한 해시는 실용적 충돌 가능).
* **길이 확장 공격**: 일부 Merkle–Damgård 계열 해시에서 발생하며, H(message)만 알면 H(message || padding || more) 계산 가능하다 → HMAC로 방지한다.

---

# 성능과 구현 고려사항

* **속도 vs 안전성**: 비암호학적 해시(예: MurmurHash)는 매우 빠르지만 보안 목적에는 부적합하다.
* **하드웨어 가속**: 일부 CPU는 SHA 연산 가속 명령어를 가지고 있어 성능 향상이 가능하다.
* **메모리/입력 크기**: 큰 파일 처리 시 스트리밍 방식으로 블록 단위 처리해야 한다.
* **엔디안(Endian)**: 바이트 정렬을 맞춰야 같은 플랫폼 간 동일 결과를 보장한다.

---

# 해시값을 숫자로 치환할 때 주의점

* 해시는 보통 바이트 배열(예: 32바이트)이다. 숫자형(예: 64비트)으로 변환하면 정보가 손실된다(충돌 확률 상승).
* 변환 방법: 해시의 일부 바이트를 선택해 `uint64_t`로 합치거나 전체 해시를 큰 정수로 해석할 수 있다.
* 보안 관점: 해시 전체 대신 앞/뒷부분만 숫자로 쓸 경우 공격 표면이 늘어난다.

---

# 요약(한 문장 핵심)

> 해시 알고리즘은 입력을 고정 길이의 ‘지문’으로 변환하는 단방향 함수이며, 데이터 무결성·인증·검색 등에서 핵심적인 역할을 하되 목적(성능 vs 보안)에 따라 적절한 알고리즘과 보안 보조( salt, KDF, HMAC )를 반드시 사용해야 한다.